#!/usr/bin/env perl
# Sockpuppet: record and automate HTTP streams

# Copyright 2019 Seeq Inc. and contributors
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Usage: ./sockpuppet listenport host:destport > outfile
# e.g.   ./sockpuppet 3001 localhost:3000 > session
#
# You can also extend sockpuppet by using it from another perl script:
#
#   BEGIN { do "sockpuppet" or die }    # import sockpuppet:: stuff
#   my $proxy = sockpuppet::proxy->new(3001, "localhost", 3000);
#   ...                                 # customize $proxy if you want to
#   $proxy->io_loop;                    # never returns

use v5.14;
use strict;
use warnings;


# CLI logic
# Don't do anything if we're being used as a library.

unless (caller)
{
  my ($listenport, $dest) = @ARGV;

  unless ($listenport =~ /^\d+$/
      and $dest       =~ /^\S+:\d+$/)
  {
    print STDERR "$0: invalid argument syntax @ARGV\n";
    print STDERR "  (expected \"$0 sourceport desthost:destport\")\n";
    exit 1;
  }

  my ($desthost, $destport) = split /:/, $dest;

  $SIG{INT} = $SIG{TERM} = sub
  {
    sockpuppet::total_runtime->stop;
    sockpuppet::print_timing_summary;
    exit 0;
  };

  sockpuppet::total_runtime->start;
  print STDERR "sockpuppet: starting proxy; Ctrl+C to exit\n";
  sockpuppet::proxy->new($listenport, $desthost, $destport)
                   ->io_loop;
}


# Accounting timer
# Used internally to accumulate time spent doing various bookkeeping things
# within sockpuppet. The idea is to figure out how much sockpuppet may have
# contributed to any performance reduction that occurred while using it.

package sockpuppet::timer;

use Time::HiRes qw/time/;

sub new
{
  my ($class) = @_;
  bless { running => 0,
          time    => 0 }, $class;
}

sub start
{
  my $self = shift;
  $$self{time} -= Time::HiRes::time() unless $$self{running};
  $$self{running} = 1;
  $self;
}

sub stop
{
  my $self = shift;
  $$self{time} += Time::HiRes::time() if $$self{running}:
  $$self{running} = 0;
  $self;
}

sub time
{
  my $self = shift;
  $$self{running} ? Time::HiRes::time() + $$self{time} : $$self{time};
}


# Utilities/globals
# Stuff for file descriptors, etc.

package sockpuppet;

use constant trace_overhead          => sockpuppet::timer->new;
use constant http_rewrite_overhead   => sockpuppet::timer->new;
use constant follower_parse_overhead => sockpuppet::timer->new;
use constant select_loop_time        => sockpuppet::timer->new;
use constant total_runtime           => sockpuppet::timer->new;

sub fd_write
{
  # fd_write($fd, $buf): write the entirety of a buffer to fd, retrying as long
  # as we get partial writes. Die if we encounter a write error.
  my $file = shift;
  for (my ($offset, $len, $n) = (0, length $_[0], 0);
       $len and $n = syswrite($file, $_[0], $len, $offset) // die $!;
       $offset += $n, $len -= $n) {}
}

sub print_timing_summary
{
  my $total          = total_runtime->time || 1;
  my $other_overhead = total_runtime->time
                     - http_rewrite_overhead->time
                     - follower_parse_overhead->time
                     - trace_overhead->time
                     - select_loop_time->time;

  printf STDERR q{TIMING SUMMARY
    total runtime:           %4.3fs
    IO blocked:              %4.3fs (%.1f%%)
    HTTP rewrite overhead:   %4.3fs (%.1f%%)
    follower parse overhead: %4.3fs (%.1f%%)
    trace overhead:          %4.3fs (%.1f%%)
    other overhead:          %4.3fs (%.1f%%)} . "\n",

    total_runtime->time,
    select_loop_time->time,        select_loop_time->time        / $total * 100,
    http_rewrite_overhead->time,   http_rewrite_overhead->time   / $total * 100,
    follower_parse_overhead->time, follower_parse_overhead->time / $total * 100,
    trace_overhead->time,          trace_overhead->time          / $total * 100,
    $other_overhead,               $other_overhead               / $total * 100;
}


# Unidirectional stream states
# A finite state machine of functions that parse follower-buffered data and emit
# next states and write events. Each has this signature:
#
#   ($follower, $data, $starttime, $endtime) -> state' | undef
#
# If the function returns a new state, it should update $data in place.
#
# Some state functions stash data on the follower object for performance
# reasons; when they do, the keys will end with an underscore.

package sockpuppet;

our %stream_states;
sub defstreamstate { $stream_state{+shift} = shift }
sub streamstate
{
  $stream_states{$_[0]} // die "nonexistent stream state: $_[0]";
}

defstreamstate http_length => sub
{
  # Log an event once we have the declared length-worth of stuff. If this state
  # is in use, the follower will have two fields on it:
  #
  #   http_headers_
  #   http_content_length_

  my $f = shift;
  if (length $_[0] == $$f{http_content_length_})
  {
    $f->event($$f{http_status_},
              $$f{http_headers_},
              $_[0]);
    $_[0] = "";
    'eof';
  }
  undef;
};

defstreamstate http_chunked => sub
{
  # Accumulate chunked data in memory until we get EOF. It isn't technically
  # difficult to emit intermediate events, but it makes our output format
  # noisier.
  #
  # This function is always invoked with the buffer placed at the beginning of a
  # chunk header. Data is accumulated in $$f{http_chunked_buffer_}.

  my $f = shift;
  while ($_[0] =~ /^([0-9a-fA-F]+)\r\n/s)
  {
    my $h = $1;
    my $n = hex $h;
    if ($n)
    {
      $$f{http_chunked_buffer_} .= substr $_[0], length($h), $n;
      $_[0] = substr $_[0], length($h) + $n + 4;
    }
    else
    {
      # End of stream
      $f->event($$f{http_status_},
                $$f{http_headers_},
                $$f{http_chunked_buffer_});
      $_[0] = "";
      return 'eof';
    }
  }
  undef;
};

defstreamstate http => sub
{
  # Once the headers have been parsed, we store http_headers_ and http_status_
  # on the follower. We also parse the content-length header if we transfer to
  # the http_length state.
  my $f = shift;
  return undef unless $_[0] =~ /^(.*?)(\r?\n\r?\n)/s;

  $$f{http_headers_} = $1;
  $_[0] = substr $_[0], length($$f{http_headers_}) + length($2);

  ($$f{http_status_}) = $$f{http_headers_} =~ /^(.*)/;

  # Four possibilities once we have the headers.
  #
  # 1. Websocket upgrade -> 'websocket' state
  # 2. Content-Length found: set substate to "length"
  # 3. "Transfer-encoding: chunked" found: set substate to "chunked"
  # 4. No content length or transfer encoding: transition to EOF state

  if ($$f{http_headers_} =~ /connection\h*:\h*upgrade/i
      && $$f{http_headers_} =~ /upgrade\h*:\h*websocket/i)
  {
    # All set: we are now a websocket.
    delete $$f{http_state_};
    $f->event('websocket upgrade', $$f{http_headers_}, "");
    return 'websocket';
  }
  elsif ($$f{http_headers_} =~ /^content-length\h*:\h*(\d+)/mi)
  {
    $$f{http_content_length_} = $1;
    $f->event("content-length: $$f{http_content_length}",
              $$f{http_headers_},
              "");
    return 'http_length';
  }
  elsif ($$f{http_headers_} =~ /^transfer-encoding\h*:\h*chunked/mi)
  {
    $$f{http_chunked_buffer_} = "";
    $f->event("transfer-encoding: chunked", $$f{http_headers_}, "");
    return 'http_chunked';
  }
  else
  {
    $f->event($$f{http_status_}, $$f{http_headers_}, "");
    return 'eof';
  }
};

defstreamstate closed => sub
{
  die "no further data expected along (half?)closed socket: $_[1]";
};

defstreamstate eof => sub
{
  die "no further data expected beyond EOF: $_[1]";
};


# Stream follower
# Parses and emits data for a unidirectional datastream within a TCP connection.
# Followers are paired with the other-directional datastream so they can verify
# state for things like handshaking protocols -- e.g. websocket setup and
# ping/pong events.

package sockpuppet::follower;

use Scalar::Util qw/weaken/;
use Time::HiRes  qw/time/;

sub new
{
  my ($class, $trace_file, $conn_id, $updown, $state) = @_;
  sockpuppet::streamstate $state;       # assert that it exists
  bless { trace_file => $file,
          conn_id    => $conn_id,
          pair       => undef,
          updown     => $updown,
          state      => $state,
          buf        => "",
          start      => undef,
          end        => undef}, $class;
}

sub pair { shift->{pair} }

sub pair_with
{
  my $self = shift;
  weaken($$self{pair} = shift);
  $self;
}

sub ping
{
  # Update timing information even if no data is observable yet. This is used to
  # notify the follower that socket IO is happening but in a buffered/pending
  # state -- such as when sockpuppet::connection is collecting HTTP request data
  # but hasn't yet rewritten it.
  my $self = shift;
  $$self{start} //= ($$self{end} = time());
  $self;
}

sub event
{
  # $self->event($notes, $headings, $data) -> $self
  # Logs an event to the trace file, blocking until the full event has been
  # committed to the kernel. Track the amount of time we spend blocked here
  # (both CPU and IO).
  my $self = shift;
  trace_overhead->start;
  sockpuppet::fd_write(
    $$self{trace_file},
    join "\t", @$self{"start", "end", "conn_id", "updown", "state"},
               $_[0] =~ y/\t/ /r,
               unpack("H*", $_[1]),
               unpack("H*", $_[2]) . "\n");
  trace_overhead->stop;
  $self;
}

sub data
{
  my $self = shift->ping;
  $$self{buf} .= shift;

  # Parse link state. If we get a state change, collapse our timeframe on the
  # assumption that the most recent data caused that change. Each state change
  # also triggers a reparse under the new state.
  while (1)
  {
    follower_parse_overhead->start;
    my $s = sockpuppet::streamstate($$self{state})->(
              $self, @$self{"buf", "start", "end"});
    follower_parse_overhead->stop;

    return $self unless defined $s;
    sockpuppet::streamstate($$self{state} = $s);
    $$self{start} = $$self{end};
  }
}

sub close
{
  my $self = shift->ping;
  $$self{state} = 'closed';
  return $self unless length $$self{buf};

  # If we have data in the buffer, it means we failed to process something. Log
  # the current state with a note about unexpected EOF.
  $self->event("unexpected EOF", "", $$self{buf});
}


# TCP connection class
# Forwards data bidirectionally along a single TCP stream, capturing traffic
# each way and applying minimal HTTP rewriting in the process. This class
# manages read/write buffering and delegates parsing to sockpuppet::follower.

package sockpuppet::connection;

use constant BUF_LIMIT => 65536;
our $connection_id = 0;

sub new
{
  my ($class, $trace_file, $host, $client_sock, $server_sock) = @_;
  my $id    = $connection_id++;
  my $upf   = sockpuppet::follower->new($trace_file, $id, up   => 'http_req');
  my $downf = sockpuppet::follower->new($trace_file, $id, down => 'http_res');

  bless { up_follower    => $upf->pair_with($downf),
          down_follower  => $downf->pair_with($upf),
          connection_id  => $id,
          client_sock    => $client_sock,
          server_sock    => $server_sock,
          client_fd      => fileno $client_sock,
          server_fd      => fileno $server_sock,
          host           => $host,
          http_rewritten => 0,
          uplink_buf     => "",
          downlink_buf   => "" }, $class;
}

sub is_ok
{
  defined shift->{client_sock};
}

sub close
{
  my ($self) = @_;

  if (length $$self{downlink_buf})
  {
    # Download data is written to the follower on read, so no need to write it
    # here.
    sockpuppet::fd_write $$self{client_sock}, $$self{downlink_buf};
  }

  if (length $$self{uplink_buf})
  {
    $$self{up_follower}->data($$self{uplink_buf});
    sockpuppet::fd_write $$self{server_sock}, $$self{uplink_buf};
  }

  $$self{down_follower}->close;
  $$self{up_follower}->close;

  close $$self{client_sock};
  close $$self{server_sock};

  $$self{client_sock} = $$self{server_sock} = undef;
  $self;
}

sub prepare_select_read
{
  # ($self, $read_fd_vec, $err_fd_vec)
  my $self = shift;
  vec($_[0], $$self{client_fd}, 1) = 1;
  vec($_[1], $$self{client_fd}, 1) = 1;
  vec($_[0], $$self{server_fd}, 1) = 1;
  vec($_[1], $$self{server_fd}, 1) = 1;
  $self;
}

sub prepare_select_write
{
  # ($self, $read_fd_vec, $err_fd_vec, $write_fd_vec)
  my $self = shift;

  # Important: set write bits only when the paired FDs are readable. Otherwise
  # we'll spin-wait for inbound data.
  vec($_[2], $$self{client_fd}, 1) = 1 if vec $_[0], $$self{server_fd}, 1;
  vec($_[2], $$self{server_fd}, 1) = 1 if vec $_[0], $$self{client_fd}, 1;
  $self;
}

sub do_io
{
  my ($self, $rfds, $wfds, $efds) = @_;
  my $client_r = vec $rfds, $$self{client_fd}, 1;
  my $client_w = vec $wfds, $$self{client_fd}, 1;
  my $client_e = vec $efds, $$self{client_fd}, 1;
  my $server_r = vec $rfds, $$self{server_fd}, 1;
  my $server_w = vec $wfds, $$self{server_fd}, 1;
  my $server_e = vec $efds, $$self{server_fd}, 1;

  # If we have errors, close the connection and auto-implode.
  return $self->close if $client_e || $server_e;

  # First handle downlink. We don't parse this here, but it does have a
  # follower.
  my $downbuf_size = length $$self{downlink_buf};
  if ($server_r && $downbuf_size < BUF_LIMIT)
  {
    sysread $$self{server_sock}, $$self{downlink_buf},
            BUF_LIMIT - $downbuf_size, $downbuf_size
      or return $self->close;
    $$self{down_follower}->data(substr $$self{downlink_buf}, $downbuf_size);
  }

  if ($client_w && length $$self{downlink_buf})
  {
    my $n = syswrite($$self{client_sock}, $$self{downlink_buf}) // die $!;
    $$self{downlink_buf} = substr $$self{downlink_buf}, $n;
  }

  # Now handle uplink.
  my $upbuf_size = length $$self{uplink_buf};
  if ($client_r and !$$self{http_rewritten} || $upbuf_size < BUF_LIMIT)
  {
    sysread $$self{client_sock}, $$self{uplink_buf},
            $$self{http_rewritten} ? BUF_LIMIT - $upbuf_size : BUF_LIMIT,
            $upbuf_size
      or return $self->close;

    # Start the up-follower timer as soon as we get the first piece of data,
    # even though we may have to wait for more data before we can ->data the
    # follower (since it gets rewritten headers). This helps minimize timing
    # errors for HTTP requests that span IO delays.
    $$self{up_follower}->ping;

    $self->rewrite_http_request unless $$self{http_rewritten};
  }

  if ($$self{http_rewritten} && $server_w)
  {
    my $n = syswrite($$self{server_sock}, $$self{uplink_buf}) // die $!;
    $$self{up_follower}->data(substr $$self{uplink_buf}, $upbuf_size);
    $$self{uplink_buf} = substr $$self{uplink_buf}, $n;
  }

  $self;
}

sub rewrite_http_request
{
  my ($self) = @_;
  die "already rewrote upload HTTP headers" if $$self{http_rewritten};

  # Look for the \r?\n\r?\n sequence that marks end of HTTP headers. Once we
  # have that, we can rewrite our HTTP request and mark ourselves as having
  # decoded the outbound HTTP.
  my ($http, $rest) = $$self{uplink_buf} =~ /^(.*)\r?\n\r?\n(.*)$/s
    or return $self;

  $http =~ s/^(.*) HTTP\/2\S*$/^$1 HTTP\/1.1/;
  $http =~ s/^Accept-Encoding:.*\n//m;
  $http =~ s/^Connection:.*\n//m;
  $http =~ s/^Host:.*/Host: $$self{host}/m;
  $http .= "\nConnection: close";
  $$self{http_rewritten} = 1;

  $$self{uplink_buf} = "$http\n\n$rest";
  $self;
}


# Proxy class
# Manages state involving multiple TCP connections.

package sockpuppet::proxy;
use Socket;

sub new
{
  my ($class, $source_port, $dest_host, $dest_port) = @_;

  socket  my $server_socket, PF_INET, SOCK_STREAM, getprotobyname "tcp" or die "socket: $!";
  setsockopt $server_socket, SOL_SOCKET, SO_REUSEADDR, pack l => 1      or die "setsockopt: $!";
  bind       $server_socket, sockaddr_in $source_port, INADDR_LOOPBACK  or die "bind: $!";
  listen     $server_socket, SOMAXCONN                                  or die "listen: $!";

  my $dest_paddr = sockaddr_in $dest_port, inet_aton $dest_host || die "no host: $dest_host";

  bless { connections    => [],
          trace_file     => \*STDOUT,
          dest_paddr     => $dest_paddr,
          dest_host      => $dest_host,
          dest_port      => $dest_port,
          dest_http_host => "$dest_host:$dest_port",
          server_fd      => fileno $server_socket,
          server_socket  => $server_socket }, $class;
}

sub io_step
{
  my ($self, $half_timeout) = @_;
  my $cs = $$self{connections};

  my $rfds = "";
  my $wfds = "";
  my $efds = "";
  vec($rfds, $$self{server_fd}, 1) = 1;

  @$cs = grep $_->is_ok, @$cs;
  $_->prepare_select_read($rfds, $efds) for @$cs;
  sockpuppet::select_loop_time->start;
  select $rfds, undef, $efds, $half_timeout;
  sockpuppet::select_loop_time->stop;

  $_->prepare_select_write($rfds, $efds, $wfds) for @$cs;
  sockpuppet::select_loop_time->start;
  select undef, $wfds, undef, $half_timeout if unpack "%32b*", $wfds;
  sockpuppet::select_loop_time->stop;

  # First, do IO on existing connections.
  $_->do_io($rfds, $wfds, $efds) for @$cs;

  # Now accept any connections on the inbound port.
  if (vec $rfds, $$self{server_fd}, 1)
  {
    my $paddr = accept(my $client_sock, $$self{server_socket});

    # Connect to the real server.
    socket my $server_sock, PF_INET, SOCK_STREAM, getprotobyname "tcp" or die "socket: $!";
    connect   $server_sock, $$self{dest_paddr}                         or die "connect: $!";

    push @$cs, sockpuppet::connection->new(
                 $$self{trace_file},
                 $$self{dest_http_host},
                 $client_sock,
                 $server_sock);
  }

  $self;
}

sub io_loop
{
  my $self = shift;
  $self->io_step while 1;
}


1;
